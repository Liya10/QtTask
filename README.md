#1.Найдите ошибки в коде

Красный выделенные строки, которые подверглись изменению.
Эта функция была протестирована и исправлена.

QString findString(QString in)
{
     QString result;
      QRegExp rx("(\\b[A-Z][a-z]+\\s\\b[A-Z].(\\b[A-Z].){0,1})");
      rx.indexIn(in, 0) != -1 ? result = rx.cap(1) : result = "";
       result=result.trimmed();
       result=result.toUpper();
        return result;

}

#2. Дайте ответы на вопросы

1)тип std::auto_ptr<T> гарантирует, что этот объект будет удален автоматически, если выйдет из области видимости, тем самым избежим утечки памяти.
2)Виртуальный деструктор нужен, чтобы корректно удалить объект класса-поток, имея указатель на базовый класс.
3)new выделяет память для одного элемента и вызывает его конструктор, delete вызывает его деструктор и освобождает его память. new[] выделяет память для массива элементов и вызывает их конструкторы, а delete[] вызывает их деструкторы и освобождает память массива.
4)Самым корректным очищением памяти считаю вариант C.
Во всех трех вариантах происходит выделение памяти для n элементов и беззнакого целого числа, которое обозначает число объектов. 
Поэтому запись delete [] array эквивалентен записи delete[n] array. Но в записи delete[n] array - увеличивает риск человечного фактора, так как в ходе программы значение n может измениться и перестать указывать на истинное количество элементов array. Поэтому вариант C лучше варианта A. Вариант B не рассматриваем, так как он не скомпилируется и выведет ошибку «error: expected expression».

5) Да, возможно, создать встроенную функцию. 

