# 1.Найдите ошибки в коде

Эта функция была протестирована и исправлена.

<p> QString findString(QString in)</p>
{
    <p> QString result;</p> 
     <p>  QRegExp rx("(\\b[A-Z][a-z]+\\s\\b[A-Z].(\\b[A-Z].){0,1})");</p> 
     <p>  rx.indexIn(in, 0) != -1 ? result = rx.cap(1) : result = "";</p> 
      <p >  result=result.trimmed();//тут исправили</p> 
     <p >   result=result.toUpper();//тут исправили</p> 
       <p>  return result;</p> 

}

# 2. Дайте ответы на вопросы

<p> 1)тип std::auto_ptr<T> гарантирует, что этот объект будет удален автоматически, если выйдет из области видимости, тем самым избежим утечки памяти.</p> 
<p> 2)Виртуальный деструктор нужен, чтобы корректно удалить объект класса-поток, имея указатель на базовый класс.</p> 
<p> 3)new выделяет память для одного элемента и вызывает его конструктор, delete вызывает его деструктор и освобождает его память. new[] выделяет память для массива элементов и вызывает их конструкторы, а delete[] вызывает их деструкторы и освобождает память массива.</p> 
<p> 4)Самым корректным очищением памяти считаю вариант C.</p> 
<p> Во всех трех вариантах происходит выделение памяти для n элементов и беззнакого целого числа, которое обозначает число объектов. </p> 
<p> Поэтому запись delete [] array эквивалентен записи delete[n] array. Но в записи delete[n] array - увеличивает риск человечного фактора, так как в ходе программы значение n может измениться и перестать указывать на истинное количество элементов array. Поэтому вариант C лучше варианта A. Вариант B не рассматриваем, так как он не скомпилируется и выведет ошибку «error: expected expression».</p> 

<p> 5) Да, возможно, создать встроенную функцию. </p> 

# 3. Реализуйте класс
<p>Класс был реализован, смотреть на папку QLabel_Timer</p>

# 4. Реализуйте класс
<p>в процессе, до 8 утра отправлю.</p>
